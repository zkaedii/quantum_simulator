#!/usr/bin/env python3
"""
Quantum Development Studio - Professional IDE for Quantum Computing
==================================================================

A comprehensive integrated development environment for quantum computing featuring:
- Visual quantum circuit designer with drag-and-drop interface
- Advanced code editor with quantum syntax highlighting
- Real-time quantum simulation and debugging
- Algorithm library and template system
- Collaboration and sharing features
- Professional export and deployment tools
- Integration with quantum hardware platforms

This studio transforms quantum development from complex coding to intuitive design.
"""

import tkinter as tk
from tkinter import ttk, messagebox, filedialog, scrolledtext
import json
import numpy as np
from datetime import datetime
from typing import Dict, List, Any, Optional, Tuple
import threading
import queue
import time


class QuantumGate:
    """Represents a quantum gate in the visual designer"""

    def __init__(self, gate_type: str, qubits: List[int], params: Dict[str, float] = None):
        self.gate_type = gate_type
        self.qubits = qubits
        self.params = params or {}
        self.position = (0, 0)
        self.id = f"{gate_type}_{int(time.time() * 1000)}"

    def to_dict(self) -> Dict[str, Any]:
        return {
            'id': self.id,
            'gate_type': self.gate_type,
            'qubits': self.qubits,
            'params': self.params,
            'position': self.position
        }


class QuantumCircuit:
    """Represents a quantum circuit with visual and code representations"""

    def __init__(self, num_qubits: int = 4, name: str = "Untitled Circuit"):
        self.num_qubits = num_qubits
        self.name = name
        self.gates = []
        self.created_at = datetime.now()
        self.modified_at = datetime.now()

    def add_gate(self, gate: QuantumGate):
        """Add a gate to the circuit"""
        self.gates.append(gate)
        self.modified_at = datetime.now()

    def remove_gate(self, gate_id: str):
        """Remove a gate from the circuit"""
        self.gates = [g for g in self.gates if g.id != gate_id]
        self.modified_at = datetime.now()

    def to_qiskit_code(self) -> str:
        """Generate Qiskit code for the circuit"""
        code = f"# Generated by Quantum Development Studio\n"
        code += f"# Circuit: {self.name}\n"
        code += f"# Created: {self.created_at.strftime('%Y-%m-%d %H:%M:%S')}\n\n"
        code += f"from qiskit import QuantumCircuit, execute, Aer\n"
        code += f"from qiskit.visualization import plot_histogram\n\n"
        code += f"# Create quantum circuit with {self.num_qubits} qubits\n"
        code += f"qc = QuantumCircuit({self.num_qubits}, {self.num_qubits})\n\n"

        for gate in self.gates:
            if gate.gate_type == 'H':
                code += f"qc.h({gate.qubits[0]})\n"
            elif gate.gate_type == 'X':
                code += f"qc.x({gate.qubits[0]})\n"
            elif gate.gate_type == 'Y':
                code += f"qc.y({gate.qubits[0]})\n"
            elif gate.gate_type == 'Z':
                code += f"qc.z({gate.qubits[0]})\n"
            elif gate.gate_type == 'CNOT':
                code += f"qc.cx({gate.qubits[0]}, {gate.qubits[1]})\n"
            elif gate.gate_type == 'RX':
                angle = gate.params.get('angle', 0)
                code += f"qc.rx({angle}, {gate.qubits[0]})\n"
            elif gate.gate_type == 'RY':
                angle = gate.params.get('angle', 0)
                code += f"qc.ry({angle}, {gate.qubits[0]})\n"
            elif gate.gate_type == 'RZ':
                angle = gate.params.get('angle', 0)
                code += f"qc.rz({angle}, {gate.qubits[0]})\n"

        code += f"\n# Add measurements\n"
        code += f"qc.measure_all()\n\n"
        code += f"# Execute circuit\n"
        code += f"backend = Aer.get_backend('qasm_simulator')\n"
        code += f"job = execute(qc, backend, shots=1024)\n"
        code += f"result = job.result()\n"
        code += f"counts = result.get_counts(qc)\n"
        code += f"print('Results:', counts)\n"

        return code

    def to_dict(self) -> Dict[str, Any]:
        return {
            'name': self.name,
            'num_qubits': self.num_qubits,
            'gates': [g.to_dict() for g in self.gates],
            'created_at': self.created_at.isoformat(),
            'modified_at': self.modified_at.isoformat()
        }


class VisualCircuitDesigner:
    """Visual drag-and-drop quantum circuit designer"""

    def __init__(self, parent):
        self.parent = parent
        self.circuit = QuantumCircuit(4, "New Circuit")
        self.selected_gate = None
        self.setup_ui()

    def setup_ui(self):
        """Setup the visual circuit designer interface"""

        # Main frame
        self.main_frame = ttk.Frame(self.parent)
        self.main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)

        # Toolbar
        toolbar = ttk.Frame(self.main_frame)
        toolbar.pack(fill=tk.X, pady=(0, 10))

        ttk.Label(toolbar, text="Quantum Gates:").pack(
            side=tk.LEFT, padx=(0, 10))

        # Gate buttons
        gates = [
            ('H', 'Hadamard'), ('X', 'Pauli-X'), ('Y', 'Pauli-Y'), ('Z', 'Pauli-Z'),
            ('CNOT', 'CNOT'), ('RX', 'Rotation-X'), ('RY',
                                                     'Rotation-Y'), ('RZ', 'Rotation-Z')
        ]

        for gate_type, gate_name in gates:
            btn = ttk.Button(toolbar, text=gate_type,
                             command=lambda g=gate_type: self.select_gate(g))
            btn.pack(side=tk.LEFT, padx=2)

        # Circuit controls
        controls = ttk.Frame(self.main_frame)
        controls.pack(fill=tk.X, pady=(0, 10))

        ttk.Label(controls, text="Qubits:").pack(side=tk.LEFT)
        self.qubit_var = tk.StringVar(value="4")
        qubit_spinbox = ttk.Spinbox(controls, from_=1, to=10, width=5,
                                    textvariable=self.qubit_var,
                                    command=self.update_qubits)
        qubit_spinbox.pack(side=tk.LEFT, padx=(5, 20))

        ttk.Button(controls, text="Clear Circuit",
                   command=self.clear_circuit).pack(side=tk.LEFT, padx=5)
        ttk.Button(controls, text="Simulate",
                   command=self.simulate_circuit).pack(side=tk.LEFT, padx=5)
        ttk.Button(controls, text="Generate Code",
                   command=self.generate_code).pack(side=tk.LEFT, padx=5)

        # Circuit canvas
        canvas_frame = ttk.LabelFrame(self.main_frame, text="Circuit Design")
        canvas_frame.pack(fill=tk.BOTH, expand=True)

        self.canvas = tk.Canvas(canvas_frame, bg='white', height=400)
        self.canvas.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        self.canvas.bind("<Button-1>", self.on_canvas_click)

        # Status bar
        self.status_var = tk.StringVar(
            value="Ready - Select a gate and click on the circuit")
        status_bar = ttk.Label(
            self.main_frame, textvariable=self.status_var, relief=tk.SUNKEN)
        status_bar.pack(fill=tk.X, pady=(10, 0))

        self.draw_circuit()

    def select_gate(self, gate_type: str):
        """Select a gate for placement"""
        self.selected_gate = gate_type
        self.status_var.set(
            f"Selected {gate_type} gate - Click on circuit to place")

    def update_qubits(self):
        """Update the number of qubits in the circuit"""
        try:
            new_qubits = int(self.qubit_var.get())
            if new_qubits != self.circuit.num_qubits:
                self.circuit.num_qubits = new_qubits
                self.circuit.gates = []  # Clear gates when changing qubit count
                self.draw_circuit()
        except ValueError:
            pass

    def clear_circuit(self):
        """Clear all gates from the circuit"""
        self.circuit.gates = []
        self.draw_circuit()
        self.status_var.set("Circuit cleared")

    def on_canvas_click(self, event):
        """Handle canvas click for gate placement"""
        if not self.selected_gate:
            return

        # Calculate which qubit line was clicked
        x, y = event.x, event.y
        qubit_spacing = 60
        start_y = 50

        qubit = -1
        for i in range(self.circuit.num_qubits):
            qubit_y = start_y + i * qubit_spacing
            if abs(y - qubit_y) < 25:
                qubit = i
                break

        if qubit == -1:
            return

        # For two-qubit gates, need to select control and target
        if self.selected_gate == 'CNOT':
            if hasattr(self, 'cnot_control'):
                # Second click - set target
                if qubit != self.cnot_control:
                    gate = QuantumGate('CNOT', [self.cnot_control, qubit])
                    gate.position = (x, y)
                    self.circuit.add_gate(gate)
                    delattr(self, 'cnot_control')
                    self.status_var.set("CNOT gate added")
                else:
                    self.status_var.set(
                        "Control and target must be different qubits")
            else:
                # First click - set control
                self.cnot_control = qubit
                self.status_var.set("CNOT control set - click target qubit")
                return
        else:
            # Single qubit gate
            params = {}
            if self.selected_gate in ['RX', 'RY', 'RZ']:
                # Get rotation angle
                angle = self.get_rotation_angle()
                if angle is None:
                    return
                params['angle'] = angle

            gate = QuantumGate(self.selected_gate, [qubit], params)
            gate.position = (x, y)
            self.circuit.add_gate(gate)
            self.status_var.set(
                f"{self.selected_gate} gate added to qubit {qubit}")

        self.draw_circuit()

    def get_rotation_angle(self) -> Optional[float]:
        """Get rotation angle from user"""
        dialog = tk.Toplevel(self.parent)
        dialog.title("Rotation Angle")
        dialog.geometry("300x150")
        dialog.transient(self.parent)
        dialog.grab_set()

        ttk.Label(dialog, text="Enter rotation angle (radians):").pack(pady=10)

        angle_var = tk.StringVar(value="1.5708")  # œÄ/2
        entry = ttk.Entry(dialog, textvariable=angle_var)
        entry.pack(pady=5)
        entry.focus()

        result = [None]

        def ok_clicked():
            try:
                result[0] = float(angle_var.get())
                dialog.destroy()
            except ValueError:
                messagebox.showerror("Error", "Please enter a valid number")

        def cancel_clicked():
            dialog.destroy()

        button_frame = ttk.Frame(dialog)
        button_frame.pack(pady=20)
        ttk.Button(button_frame, text="OK", command=ok_clicked).pack(
            side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="Cancel",
                   command=cancel_clicked).pack(side=tk.LEFT, padx=5)

        entry.bind('<Return>', lambda e: ok_clicked())

        dialog.wait_window()
        return result[0]

    def draw_circuit(self):
        """Draw the quantum circuit on canvas"""
        self.canvas.delete("all")

        if self.circuit.num_qubits == 0:
            return

        canvas_width = self.canvas.winfo_width() or 800
        canvas_height = self.canvas.winfo_height() or 400

        qubit_spacing = min(60, (canvas_height - 100) //
                            max(self.circuit.num_qubits, 1))
        start_y = 50

        # Draw qubit lines
        for i in range(self.circuit.num_qubits):
            y = start_y + i * qubit_spacing
            self.canvas.create_line(30, y, canvas_width - 30, y, width=2)
            self.canvas.create_text(15, y, text=f"|{i}‚ü©", anchor=tk.E)

        # Draw gates
        gate_x = 80
        for gate in self.circuit.gates:
            if gate.gate_type == 'CNOT':
                control_y = start_y + gate.qubits[0] * qubit_spacing
                target_y = start_y + gate.qubits[1] * qubit_spacing

                # Control dot
                self.canvas.create_oval(gate_x - 5, control_y - 5,
                                        gate_x + 5, control_y + 5,
                                        fill='black')

                # Target circle
                self.canvas.create_oval(gate_x - 10, target_y - 10,
                                        gate_x + 10, target_y + 10,
                                        outline='black', width=2, fill='white')
                self.canvas.create_line(gate_x, target_y - 8,
                                        gate_x, target_y + 8, width=2)
                self.canvas.create_line(gate_x - 8, target_y,
                                        gate_x + 8, target_y, width=2)

                # Connection line
                self.canvas.create_line(
                    gate_x, control_y, gate_x, target_y, width=2)
            else:
                # Single qubit gate
                qubit_y = start_y + gate.qubits[0] * qubit_spacing

                # Gate box
                self.canvas.create_rectangle(gate_x - 15, qubit_y - 12,
                                             gate_x + 15, qubit_y + 12,
                                             outline='black', fill='lightblue')

                # Gate label
                label = gate.gate_type
                if gate.gate_type in ['RX', 'RY', 'RZ']:
                    angle = gate.params.get('angle', 0)
                    label += f"({angle:.2f})"

                self.canvas.create_text(gate_x, qubit_y, text=label,
                                        font=('Arial', 8, 'bold'))

            gate_x += 60

    def simulate_circuit(self):
        """Simulate the quantum circuit"""
        if not self.circuit.gates:
            messagebox.showwarning("Warning", "Circuit is empty")
            return

        # Simple simulation using our quantum simulator
        try:
            from quantum_simulator import QuantumSimulator, GateType, GateOperation

            simulator = QuantumSimulator(self.circuit.num_qubits)

            for gate in self.circuit.gates:
                if gate.gate_type == 'H':
                    simulator.add_gate(GateType.HADAMARD, gate.qubits[0])
                elif gate.gate_type == 'X':
                    simulator.add_gate(GateType.PAULI_X, gate.qubits[0])
                elif gate.gate_type == 'Y':
                    simulator.add_gate(GateType.PAULI_Y, gate.qubits[0])
                elif gate.gate_type == 'Z':
                    simulator.add_gate(GateType.PAULI_Z, gate.qubits[0])
                elif gate.gate_type == 'CNOT':
                    simulator.add_gate(
                        GateType.CNOT, gate.qubits[0], gate.qubits[1])
                elif gate.gate_type == 'RX':
                    angle = gate.params.get('angle', 0)
                    simulator.add_gate(
                        GateType.RX, gate.qubits[0], angle=angle)
                elif gate.gate_type == 'RY':
                    angle = gate.params.get('angle', 0)
                    simulator.add_gate(
                        GateType.RY, gate.qubits[0], angle=angle)
                elif gate.gate_type == 'RZ':
                    angle = gate.params.get('angle', 0)
                    simulator.add_gate(
                        GateType.RZ, gate.qubits[0], angle=angle)

            # Run simulation
            results = simulator.simulate()

            # Show results
            self.show_simulation_results(results)

        except ImportError:
            messagebox.showerror("Error", "Quantum simulator not available")
        except Exception as e:
            messagebox.showerror("Simulation Error",
                                 f"Error during simulation: {str(e)}")

    def show_simulation_results(self, results):
        """Show simulation results in a new window"""
        results_window = tk.Toplevel(self.parent)
        results_window.title("Simulation Results")
        results_window.geometry("500x400")

        # Results text
        text_widget = scrolledtext.ScrolledText(results_window, wrap=tk.WORD)
        text_widget.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)

        # Format results
        text_widget.insert(tk.END, f"Circuit: {self.circuit.name}\n")
        text_widget.insert(tk.END, f"Qubits: {self.circuit.num_qubits}\n")
        text_widget.insert(tk.END, f"Gates: {len(self.circuit.gates)}\n\n")

        if 'final_state' in results:
            state = results['final_state']
            text_widget.insert(tk.END, "Final Quantum State:\n")
            for i, amplitude in enumerate(state):
                if abs(amplitude) > 1e-10:  # Only show non-zero amplitudes
                    binary = format(i, f'0{self.circuit.num_qubits}b')
                    prob = abs(amplitude) ** 2
                    text_widget.insert(
                        tk.END, f"|{binary}‚ü©: {amplitude:.4f} (prob: {prob:.4f})\n")

        if 'measurement_probabilities' in results:
            text_widget.insert(tk.END, "\nMeasurement Probabilities:\n")
            probs = results['measurement_probabilities']
            for i, prob in enumerate(probs):
                if prob > 1e-10:
                    binary = format(i, f'0{self.circuit.num_qubits}b')
                    text_widget.insert(tk.END, f"|{binary}‚ü©: {prob:.4f}\n")

        text_widget.config(state=tk.DISABLED)

    def generate_code(self):
        """Generate and show code for the circuit"""
        if not self.circuit.gates:
            messagebox.showwarning("Warning", "Circuit is empty")
            return

        code_window = tk.Toplevel(self.parent)
        code_window.title("Generated Code")
        code_window.geometry("700x500")

        # Code text
        text_widget = scrolledtext.ScrolledText(code_window, wrap=tk.NONE,
                                                font=('Consolas', 10))
        text_widget.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)

        # Generate code
        code = self.circuit.to_qiskit_code()
        text_widget.insert(tk.END, code)

        # Copy button
        def copy_code():
            code_window.clipboard_clear()
            code_window.clipboard_append(code)
            messagebox.showinfo("Copied", "Code copied to clipboard")

        ttk.Button(code_window, text="Copy to Clipboard",
                   command=copy_code).pack(pady=5)


class CodeEditor:
    """Advanced code editor with quantum syntax highlighting"""

    def __init__(self, parent):
        self.parent = parent
        self.setup_ui()
        self.setup_syntax_highlighting()

    def setup_ui(self):
        """Setup the code editor interface"""

        # Main frame
        self.main_frame = ttk.Frame(self.parent)
        self.main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)

        # Toolbar
        toolbar = ttk.Frame(self.main_frame)
        toolbar.pack(fill=tk.X, pady=(0, 10))

        ttk.Button(toolbar, text="New", command=self.new_file).pack(
            side=tk.LEFT, padx=2)
        ttk.Button(toolbar, text="Open", command=self.open_file).pack(
            side=tk.LEFT, padx=2)
        ttk.Button(toolbar, text="Save", command=self.save_file).pack(
            side=tk.LEFT, padx=2)
        ttk.Button(toolbar, text="Run", command=self.run_code).pack(
            side=tk.LEFT, padx=10)

        # Editor frame
        editor_frame = ttk.LabelFrame(
            self.main_frame, text="Quantum Code Editor")
        editor_frame.pack(fill=tk.BOTH, expand=True)

        # Line numbers frame
        line_frame = tk.Frame(editor_frame)
        line_frame.pack(fill=tk.Y, side=tk.LEFT)

        self.line_text = tk.Text(line_frame, width=4, padx=3, takefocus=0,
                                 border=0, state='disabled', wrap='none',
                                 bg='#f0f0f0', fg='#666666')
        self.line_text.pack(side=tk.TOP, fill=tk.Y)

        # Code text widget
        self.code_text = scrolledtext.ScrolledText(editor_frame, wrap=tk.NONE,
                                                   font=('Consolas', 11),
                                                   undo=True, maxundo=50)
        self.code_text.pack(fill=tk.BOTH, expand=True, padx=(5, 0), pady=5)

        # Bind events
        self.code_text.bind('<KeyRelease>', self.on_text_change)
        self.code_text.bind('<Button-1>', self.on_text_change)
        self.code_text.bind('<MouseWheel>', self.on_scroll)

        # Output frame
        output_frame = ttk.LabelFrame(self.main_frame, text="Output")
        output_frame.pack(fill=tk.X, pady=(10, 0))

        self.output_text = scrolledtext.ScrolledText(output_frame, height=8,
                                                     font=('Consolas', 9))
        self.output_text.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)

        # Load example code
        self.load_example_code()
        self.update_line_numbers()

    def setup_syntax_highlighting(self):
        """Setup syntax highlighting for quantum programming"""

        # Configure text tags for syntax highlighting
        self.code_text.tag_configure(
            "keyword", foreground="#0000FF", font=('Consolas', 11, 'bold'))
        self.code_text.tag_configure("string", foreground="#008000")
        self.code_text.tag_configure(
            "comment", foreground="#808080", font=('Consolas', 11, 'italic'))
        self.code_text.tag_configure(
            "quantum", foreground="#FF6600", font=('Consolas', 11, 'bold'))
        self.code_text.tag_configure("number", foreground="#FF0000")

    def highlight_syntax(self):
        """Apply syntax highlighting to the code"""

        content = self.code_text.get(1.0, tk.END)

        # Remove existing tags
        for tag in ["keyword", "string", "comment", "quantum", "number"]:
            self.code_text.tag_remove(tag, 1.0, tk.END)

        # Python keywords
        keywords = ['import', 'from', 'def', 'class', 'if', 'else', 'elif', 'for', 'while',
                    'return', 'try', 'except', 'with', 'as', 'lambda', 'and', 'or', 'not']

        # Quantum keywords
        quantum_keywords = ['QuantumCircuit', 'qc', 'qubit', 'quantum', 'gate', 'measurement',
                            'hadamard', 'cnot', 'pauli', 'rotation', 'entanglement', 'superposition']

        lines = content.split('\n')
        for line_num, line in enumerate(lines, 1):
            # Highlight comments
            if '#' in line:
                comment_start = line.find('#')
                start_idx = f"{line_num}.{comment_start}"
                end_idx = f"{line_num}.{len(line)}"
                self.code_text.tag_add("comment", start_idx, end_idx)

            # Highlight strings
            for quote in ['"', "'"]:
                start = 0
                while True:
                    start = line.find(quote, start)
                    if start == -1:
                        break
                    end = line.find(quote, start + 1)
                    if end == -1:
                        break
                    start_idx = f"{line_num}.{start}"
                    end_idx = f"{line_num}.{end + 1}"
                    self.code_text.tag_add("string", start_idx, end_idx)
                    start = end + 1

            # Highlight keywords
            words = line.split()
            word_start = 0
            for word in words:
                word_pos = line.find(word, word_start)
                if word_pos != -1:
                    clean_word = word.strip('()[]{},.;:')
                    if clean_word in keywords:
                        start_idx = f"{line_num}.{word_pos}"
                        end_idx = f"{line_num}.{word_pos + len(clean_word)}"
                        self.code_text.tag_add("keyword", start_idx, end_idx)
                    elif clean_word in quantum_keywords:
                        start_idx = f"{line_num}.{word_pos}"
                        end_idx = f"{line_num}.{word_pos + len(clean_word)}"
                        self.code_text.tag_add("quantum", start_idx, end_idx)
                    elif clean_word.replace('.', '').replace('-', '').isdigit():
                        start_idx = f"{line_num}.{word_pos}"
                        end_idx = f"{line_num}.{word_pos + len(clean_word)}"
                        self.code_text.tag_add("number", start_idx, end_idx)
                    word_start = word_pos + len(word)

    def on_text_change(self, event=None):
        """Handle text changes for syntax highlighting and line numbers"""
        self.update_line_numbers()
        # Delay syntax highlighting to avoid performance issues
        self.parent.after(100, self.highlight_syntax)

    def on_scroll(self, event):
        """Synchronize line numbers with code text scrolling"""
        self.line_text.yview_moveto(self.code_text.yview()[0])

    def update_line_numbers(self):
        """Update line numbers display"""
        self.line_text.config(state='normal')
        self.line_text.delete(1.0, tk.END)

        line_count = int(self.code_text.index('end-1c').split('.')[0])
        line_numbers = '\n'.join(str(i) for i in range(1, line_count))
        self.line_text.insert(1.0, line_numbers)

        self.line_text.config(state='disabled')

    def load_example_code(self):
        """Load example quantum code"""
        example_code = '''# Quantum Computing Example - Bell State Creation
from qiskit import QuantumCircuit, execute, Aer
from qiskit.visualization import plot_histogram
import numpy as np

def create_bell_state():
    """Create a Bell state using quantum entanglement"""
    
    # Create quantum circuit with 2 qubits and 2 classical bits
    qc = QuantumCircuit(2, 2)
    
    # Apply Hadamard gate to first qubit (creates superposition)
    qc.h(0)
    
    # Apply CNOT gate (creates entanglement)
    qc.cx(0, 1)
    
    # Add measurement
    qc.measure_all()
    
    return qc

def run_quantum_simulation():
    """Run the quantum circuit simulation"""
    
    # Create the circuit
    circuit = create_bell_state()
    
    # Get quantum simulator backend
    backend = Aer.get_backend('qasm_simulator')
    
    # Execute the circuit
    job = execute(circuit, backend, shots=1024)
    result = job.result()
    counts = result.get_counts(circuit)
    
    print("Quantum Bell State Results:")
    print(f"Measurement outcomes: {counts}")
    
    # Theoretical Bell state: 50% |00‚ü© + 50% |11‚ü©
    return counts

if __name__ == "__main__":
    results = run_quantum_simulation()
'''

        self.code_text.insert(1.0, example_code)

    def new_file(self):
        """Create a new file"""
        if messagebox.askokcancel("New File", "Clear current content?"):
            self.code_text.delete(1.0, tk.END)
            self.output_text.delete(1.0, tk.END)

    def open_file(self):
        """Open a file"""
        file_path = filedialog.askopenfilename(
            title="Open Quantum Code",
            filetypes=[("Python files", "*.py"), ("All files", "*.*")]
        )

        if file_path:
            try:
                with open(file_path, 'r', encoding='utf-8') as file:
                    content = file.read()
                    self.code_text.delete(1.0, tk.END)
                    self.code_text.insert(1.0, content)
                    self.update_line_numbers()
                    self.highlight_syntax()
            except Exception as e:
                messagebox.showerror("Error", f"Failed to open file: {str(e)}")

    def save_file(self):
        """Save the file"""
        file_path = filedialog.asksaveasfilename(
            title="Save Quantum Code",
            defaultextension=".py",
            filetypes=[("Python files", "*.py"), ("All files", "*.*")]
        )

        if file_path:
            try:
                content = self.code_text.get(1.0, tk.END)
                with open(file_path, 'w', encoding='utf-8') as file:
                    file.write(content)
                messagebox.showinfo("Saved", "File saved successfully")
            except Exception as e:
                messagebox.showerror("Error", f"Failed to save file: {str(e)}")

    def run_code(self):
        """Run the quantum code"""
        code = self.code_text.get(1.0, tk.END)

        # Clear output
        self.output_text.delete(1.0, tk.END)
        self.output_text.insert(tk.END, "Running quantum code...\n\n")
        self.output_text.update()

        # Run code in separate thread
        def run_in_thread():
            try:
                # Capture output
                import sys
                from io import StringIO

                old_stdout = sys.stdout
                sys.stdout = StringIO()

                # Execute code
                exec(code)

                # Get output
                output = sys.stdout.getvalue()
                sys.stdout = old_stdout

                # Display output
                self.parent.after(0, lambda: self.display_output(output, None))

            except Exception as e:
                sys.stdout = old_stdout
                self.parent.after(0, lambda: self.display_output("", str(e)))

        thread = threading.Thread(target=run_in_thread)
        thread.daemon = True
        thread.start()

    def display_output(self, output: str, error: Optional[str]):
        """Display code execution output"""
        self.output_text.delete(1.0, tk.END)

        if error:
            self.output_text.insert(tk.END, f"Error:\n{error}\n")
        else:
            self.output_text.insert(
                tk.END, output if output else "Code executed successfully (no output)\n")


class AlgorithmLibrary:
    """Library of quantum algorithm templates and examples"""

    def __init__(self, parent):
        self.parent = parent
        self.setup_ui()
        self.load_algorithms()

    def setup_ui(self):
        """Setup the algorithm library interface"""

        # Main frame
        self.main_frame = ttk.Frame(self.parent)
        self.main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)

        # Search frame
        search_frame = ttk.Frame(self.main_frame)
        search_frame.pack(fill=tk.X, pady=(0, 10))

        ttk.Label(search_frame, text="Search:").pack(side=tk.LEFT)
        self.search_var = tk.StringVar()
        search_entry = ttk.Entry(search_frame, textvariable=self.search_var)
        search_entry.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(5, 10))
        search_entry.bind('<KeyRelease>', self.filter_algorithms)

        ttk.Button(search_frame, text="Refresh",
                   command=self.load_algorithms).pack(side=tk.RIGHT)

        # Categories frame
        categories_frame = ttk.LabelFrame(self.main_frame, text="Categories")
        categories_frame.pack(fill=tk.X, pady=(0, 10))

        self.category_var = tk.StringVar(value="All")
        categories = ["All", "Basic Gates",
                      "Algorithms", "Applications", "Examples"]

        for i, category in enumerate(categories):
            ttk.Radiobutton(categories_frame, text=category,
                            variable=self.category_var, value=category,
                            command=self.filter_algorithms).pack(side=tk.LEFT, padx=10)

        # Algorithm list
        list_frame = ttk.LabelFrame(self.main_frame, text="Quantum Algorithms")
        list_frame.pack(fill=tk.BOTH, expand=True)

        # Treeview for algorithms
        columns = ('Name', 'Category', 'Qubits', 'Description')
        self.algorithm_tree = ttk.Treeview(
            list_frame, columns=columns, show='headings')

        for col in columns:
            self.algorithm_tree.heading(col, text=col)
            self.algorithm_tree.column(col, width=150)

        # Scrollbar
        scrollbar = ttk.Scrollbar(list_frame, orient=tk.VERTICAL,
                                  command=self.algorithm_tree.yview)
        self.algorithm_tree.configure(yscrollcommand=scrollbar.set)

        self.algorithm_tree.pack(
            side=tk.LEFT, fill=tk.BOTH, expand=True, padx=(5, 0), pady=5)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y, pady=5)

        # Buttons
        button_frame = ttk.Frame(self.main_frame)
        button_frame.pack(fill=tk.X, pady=(10, 0))

        ttk.Button(button_frame, text="View Code",
                   command=self.view_algorithm).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="Load to Editor",
                   command=self.load_to_editor).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="Create Circuit",
                   command=self.create_circuit).pack(side=tk.LEFT, padx=5)

    def load_algorithms(self):
        """Load quantum algorithms into the library"""

        # Clear existing items
        for item in self.algorithm_tree.get_children():
            self.algorithm_tree.delete(item)

        self.algorithms = [
            {
                'name': 'Bell State',
                'category': 'Basic Gates',
                'qubits': 2,
                'description': 'Create maximally entangled Bell state',
                'code': '''# Bell State Creation
qc = QuantumCircuit(2, 2)
qc.h(0)        # Hadamard on qubit 0
qc.cx(0, 1)    # CNOT gate
qc.measure_all()'''
            },
            {
                'name': 'GHZ State',
                'category': 'Basic Gates',
                'qubits': 3,
                'description': 'Three-qubit maximally entangled state',
                'code': '''# GHZ State Creation
qc = QuantumCircuit(3, 3)
qc.h(0)        # Hadamard on qubit 0
qc.cx(0, 1)    # CNOT 0->1
qc.cx(0, 2)    # CNOT 0->2
qc.measure_all()'''
            },
            {
                'name': "Grover's Algorithm",
                'category': 'Algorithms',
                'qubits': 3,
                'description': 'Quantum search algorithm with quadratic speedup',
                'code': '''# Grover's Algorithm (3 qubits, searching for |101>)
import numpy as np

qc = QuantumCircuit(3, 3)

# Initialize superposition
for i in range(3):
    qc.h(i)

# Oracle (mark |101>)
qc.cz(0, 2)

# Diffusion operator
for i in range(3):
    qc.h(i)
    qc.x(i)

qc.h(2)
qc.ccx(0, 1, 2)
qc.h(2)

for i in range(3):
    qc.x(i)
    qc.h(i)

qc.measure_all()'''
            },
            {
                'name': 'Quantum Fourier Transform',
                'category': 'Algorithms',
                'qubits': 3,
                'description': 'Quantum version of discrete Fourier transform',
                'code': '''# Quantum Fourier Transform (3 qubits)
qc = QuantumCircuit(3, 3)

# QFT implementation
qc.h(2)
qc.cp(np.pi/2, 1, 2)
qc.cp(np.pi/4, 0, 2)

qc.h(1)
qc.cp(np.pi/2, 0, 1)

qc.h(0)

# Swap qubits to reverse order
qc.swap(0, 2)

qc.measure_all()'''
            },
            {
                'name': 'Quantum Teleportation',
                'category': 'Applications',
                'qubits': 3,
                'description': 'Transfer quantum state using entanglement',
                'code': '''# Quantum Teleportation Protocol
qc = QuantumCircuit(3, 3)

# Prepare state to teleport (example: |+> state)
qc.h(0)

# Create Bell pair between qubits 1 and 2
qc.h(1)
qc.cx(1, 2)

# Bell measurement on qubits 0 and 1
qc.cx(0, 1)
qc.h(0)
qc.measure(0, 0)
qc.measure(1, 1)

# Apply corrections to qubit 2
qc.cx(1, 2)
qc.cz(0, 2)

qc.measure(2, 2)'''
            },
            {
                'name': 'Quantum Random Walk',
                'category': 'Examples',
                'qubits': 4,
                'description': 'Quantum version of classical random walk',
                'code': '''# Quantum Random Walk
qc = QuantumCircuit(4, 4)

# Initialize coin qubit in superposition
qc.h(0)

# Apply conditional shifts
for step in range(3):
    # Conditional shift operations
    qc.cx(0, 1)
    qc.cx(0, 2)
    qc.cx(0, 3)
    
    # Coin flip for next step
    qc.h(0)

qc.measure_all()'''
            },
            {
                'name': 'Quantum Phase Estimation',
                'category': 'Algorithms',
                'qubits': 4,
                'description': 'Estimate eigenvalue phases of unitary operators',
                'code': '''# Quantum Phase Estimation
qc = QuantumCircuit(4, 4)

# Initialize counting qubits
for i in range(3):
    qc.h(i)

# Initialize eigenstate (example: |1>)
qc.x(3)

# Controlled unitary operations
for i in range(3):
    for j in range(2**i):
        qc.cp(2*np.pi/8, i, 3)  # Example unitary

# Inverse QFT on counting qubits
# (simplified version)
qc.h(2)
qc.cp(-np.pi/2, 1, 2)
qc.h(1)
qc.cp(-np.pi/4, 0, 2)
qc.cp(-np.pi/2, 0, 1)
qc.h(0)

qc.measure_all()'''
            }
        ]

        # Populate treeview
        for alg in self.algorithms:
            self.algorithm_tree.insert('', tk.END, values=(
                alg['name'], alg['category'], alg['qubits'], alg['description']
            ))

    def filter_algorithms(self, event=None):
        """Filter algorithms based on search and category"""
        search_term = self.search_var.get().lower()
        category = self.category_var.get()

        # Clear current items
        for item in self.algorithm_tree.get_children():
            self.algorithm_tree.delete(item)

        # Filter and display
        for alg in self.algorithms:
            # Check category filter
            if category != "All" and alg['category'] != category:
                continue

            # Check search term
            if search_term and search_term not in alg['name'].lower() and \
               search_term not in alg['description'].lower():
                continue

            self.algorithm_tree.insert('', tk.END, values=(
                alg['name'], alg['category'], alg['qubits'], alg['description']
            ))

    def view_algorithm(self):
        """View selected algorithm details"""
        selection = self.algorithm_tree.selection()
        if not selection:
            messagebox.showwarning("Warning", "Please select an algorithm")
            return

        item = self.algorithm_tree.item(selection[0])
        alg_name = item['values'][0]

        # Find algorithm
        algorithm = next(
            (alg for alg in self.algorithms if alg['name'] == alg_name), None)
        if not algorithm:
            return

        # Show details window
        details_window = tk.Toplevel(self.parent)
        details_window.title(f"Algorithm: {algorithm['name']}")
        details_window.geometry("600x500")

        # Algorithm info
        info_frame = ttk.LabelFrame(details_window, text="Information")
        info_frame.pack(fill=tk.X, padx=10, pady=5)

        ttk.Label(info_frame, text=f"Name: {algorithm['name']}").pack(
            anchor=tk.W, padx=10, pady=2)
        ttk.Label(info_frame, text=f"Category: {algorithm['category']}").pack(
            anchor=tk.W, padx=10, pady=2)
        ttk.Label(info_frame, text=f"Qubits: {algorithm['qubits']}").pack(
            anchor=tk.W, padx=10, pady=2)
        ttk.Label(info_frame, text=f"Description: {algorithm['description']}").pack(
            anchor=tk.W, padx=10, pady=2)

        # Code display
        code_frame = ttk.LabelFrame(details_window, text="Code")
        code_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)

        code_text = scrolledtext.ScrolledText(
            code_frame, font=('Consolas', 10))
        code_text.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        code_text.insert(tk.END, algorithm['code'])
        code_text.config(state=tk.DISABLED)

    def load_to_editor(self):
        """Load selected algorithm to code editor"""
        selection = self.algorithm_tree.selection()
        if not selection:
            messagebox.showwarning("Warning", "Please select an algorithm")
            return

        item = self.algorithm_tree.item(selection[0])
        alg_name = item['values'][0]

        # Find algorithm
        algorithm = next(
            (alg for alg in self.algorithms if alg['name'] == alg_name), None)
        if not algorithm:
            return

        # This would need to communicate with the code editor
        messagebox.showinfo("Load to Editor",
                            f"Algorithm '{algorithm['name']}' would be loaded to the code editor")

    def create_circuit(self):
        """Create circuit from selected algorithm"""
        selection = self.algorithm_tree.selection()
        if not selection:
            messagebox.showwarning("Warning", "Please select an algorithm")
            return

        item = self.algorithm_tree.item(selection[0])
        alg_name = item['values'][0]

        # This would need to communicate with the circuit designer
        messagebox.showinfo("Create Circuit",
                            f"Circuit for '{alg_name}' would be created in the visual designer")


class QuantumStudio:
    """Main Quantum Development Studio application"""

    def __init__(self):
        self.root = tk.Tk()
        self.root.title("Quantum Development Studio - Professional IDE")
        self.root.geometry("1400x900")
        self.root.state('zoomed')  # Maximize on Windows

        # Set icon and styling
        self.setup_styling()
        self.create_menu()
        self.create_main_interface()

    def setup_styling(self):
        """Setup application styling and theme"""
        style = ttk.Style()
        style.theme_use('clam')

        # Custom colors
        style.configure('Title.TLabel', font=(
            'Arial', 16, 'bold'), foreground='#2c3e50')
        style.configure('Header.TLabel', font=(
            'Arial', 12, 'bold'), foreground='#34495e')

    def create_menu(self):
        """Create application menu bar"""
        menubar = tk.Menu(self.root)
        self.root.config(menu=menubar)

        # File menu
        file_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="File", menu=file_menu)
        file_menu.add_command(label="New Circuit", command=self.new_circuit)
        file_menu.add_command(label="Open Circuit", command=self.open_circuit)
        file_menu.add_command(label="Save Circuit", command=self.save_circuit)
        file_menu.add_separator()
        file_menu.add_command(label="Export Code", command=self.export_code)
        file_menu.add_separator()
        file_menu.add_command(label="Exit", command=self.root.quit)

        # Edit menu
        edit_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="Edit", menu=edit_menu)
        edit_menu.add_command(label="Undo", command=self.undo)
        edit_menu.add_command(label="Redo", command=self.redo)
        edit_menu.add_separator()
        edit_menu.add_command(label="Preferences",
                              command=self.show_preferences)

        # View menu
        view_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="View", menu=view_menu)
        view_menu.add_command(label="Circuit Designer",
                              command=self.show_circuit_tab)
        view_menu.add_command(label="Code Editor", command=self.show_code_tab)
        view_menu.add_command(label="Algorithm Library",
                              command=self.show_library_tab)

        # Tools menu
        tools_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="Tools", menu=tools_menu)
        tools_menu.add_command(label="Simulate Circuit",
                               command=self.simulate_circuit)
        tools_menu.add_command(label="Generate Code",
                               command=self.generate_code)
        tools_menu.add_command(label="Quantum Debugger",
                               command=self.show_debugger)

        # Help menu
        help_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="Help", menu=help_menu)
        help_menu.add_command(label="Documentation", command=self.show_docs)
        help_menu.add_command(label="Tutorials", command=self.show_tutorials)
        help_menu.add_command(label="About", command=self.show_about)

    def create_main_interface(self):
        """Create the main studio interface"""

        # Main header
        header_frame = ttk.Frame(self.root)
        header_frame.pack(fill=tk.X, padx=10, pady=5)

        ttk.Label(header_frame, text="üöÄ Quantum Development Studio",
                  style='Title.TLabel').pack(side=tk.LEFT)

        ttk.Label(header_frame, text="Professional Quantum Computing IDE",
                  style='Header.TLabel').pack(side=tk.RIGHT)

        # Main notebook for tabs
        self.notebook = ttk.Notebook(self.root)
        self.notebook.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)

        # Create tabs
        self.create_circuit_tab()
        self.create_code_tab()
        self.create_library_tab()
        self.create_collaboration_tab()

        # Status bar
        self.status_bar = ttk.Label(self.root, text="Ready - Quantum Development Studio",
                                    relief=tk.SUNKEN)
        self.status_bar.pack(fill=tk.X, side=tk.BOTTOM)

    def create_circuit_tab(self):
        """Create visual circuit designer tab"""
        circuit_frame = ttk.Frame(self.notebook)
        self.notebook.add(circuit_frame, text="üîß Circuit Designer")

        self.circuit_designer = VisualCircuitDesigner(circuit_frame)

    def create_code_tab(self):
        """Create code editor tab"""
        code_frame = ttk.Frame(self.notebook)
        self.notebook.add(code_frame, text="üíª Code Editor")

        self.code_editor = CodeEditor(code_frame)

    def create_library_tab(self):
        """Create algorithm library tab"""
        library_frame = ttk.Frame(self.notebook)
        self.notebook.add(library_frame, text="üìö Algorithm Library")

        self.algorithm_library = AlgorithmLibrary(library_frame)

    def create_collaboration_tab(self):
        """Create collaboration and sharing tab"""
        collab_frame = ttk.Frame(self.notebook)
        self.notebook.add(collab_frame, text="ü§ù Collaboration")

        # Collaboration features placeholder
        ttk.Label(collab_frame, text="üöÄ Collaboration Features",
                  style='Title.TLabel').pack(pady=20)

        features = [
            "üîÑ Real-time circuit collaboration",
            "‚òÅÔ∏è Cloud circuit storage and sharing",
            "üë• Team workspace management",
            "üí¨ Integrated chat and comments",
            "üìä Version control for quantum circuits",
            "üîó Integration with quantum cloud platforms"
        ]

        for feature in features:
            ttk.Label(collab_frame, text=feature,
                      font=('Arial', 11)).pack(pady=5, padx=50, anchor=tk.W)

        # Coming soon message
        ttk.Label(collab_frame, text="üöß Advanced collaboration features coming soon!",
                  font=('Arial', 12, 'italic'),
                  foreground='#e67e22').pack(pady=30)

    # Menu command implementations
    def new_circuit(self):
        """Create new quantum circuit"""
        self.circuit_designer.clear_circuit()
        self.status_bar.config(text="New circuit created")

    def open_circuit(self):
        """Open existing circuit file"""
        messagebox.showinfo(
            "Open Circuit", "Circuit opening functionality would be implemented here")

    def save_circuit(self):
        """Save current circuit"""
        messagebox.showinfo(
            "Save Circuit", "Circuit saving functionality would be implemented here")

    def export_code(self):
        """Export circuit as code"""
        self.circuit_designer.generate_code()

    def undo(self):
        """Undo last action"""
        self.status_bar.config(text="Undo performed")

    def redo(self):
        """Redo last undone action"""
        self.status_bar.config(text="Redo performed")

    def show_preferences(self):
        """Show preferences dialog"""
        messagebox.showinfo(
            "Preferences", "Preferences dialog would be shown here")

    def show_circuit_tab(self):
        """Switch to circuit designer tab"""
        self.notebook.select(0)

    def show_code_tab(self):
        """Switch to code editor tab"""
        self.notebook.select(1)

    def show_library_tab(self):
        """Switch to algorithm library tab"""
        self.notebook.select(2)

    def simulate_circuit(self):
        """Simulate current circuit"""
        self.circuit_designer.simulate_circuit()

    def generate_code(self):
        """Generate code from current circuit"""
        self.circuit_designer.generate_code()

    def show_debugger(self):
        """Show quantum debugger"""
        messagebox.showinfo(
            "Debugger", "Quantum debugger would be launched here")

    def show_docs(self):
        """Show documentation"""
        messagebox.showinfo(
            "Documentation", "Documentation would be opened here")

    def show_tutorials(self):
        """Show tutorials"""
        messagebox.showinfo(
            "Tutorials", "Interactive tutorials would be launched here")

    def show_about(self):
        """Show about dialog"""
        about_text = """
Quantum Development Studio
Professional IDE for Quantum Computing

Version: 1.0.0
Built with: Python, Tkinter, NumPy

Features:
‚Ä¢ Visual quantum circuit designer
‚Ä¢ Advanced code editor with syntax highlighting  
‚Ä¢ Comprehensive algorithm library
‚Ä¢ Real-time simulation and debugging
‚Ä¢ Collaboration and sharing tools
‚Ä¢ Integration with quantum platforms

¬© 2025 Quantum Computing Platform
        """
        messagebox.showinfo("About Quantum Development Studio", about_text)

    def run(self):
        """Start the Quantum Development Studio"""
        self.root.mainloop()


def main():
    """Launch Quantum Development Studio"""
    print("üöÄ Launching Quantum Development Studio...")
    print("Professional IDE for Quantum Computing")
    print("=" * 50)

    try:
        studio = QuantumStudio()
        studio.run()
    except Exception as e:
        print(f"Error launching studio: {e}")
        input("Press Enter to exit...")


if __name__ == "__main__":
    main()
